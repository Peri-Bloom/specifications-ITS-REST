/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.Composition
import org.openapitools.client.models.Error
import org.openapitools.client.models.RevisionHistory
import org.openapitools.client.models.Version
import org.openapitools.client.models.VersionedComposition

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class COMPOSITIONApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://openEHRSys.example.com/v1")
        }
    }

    /**
     * enum for parameter prefer
     */
     enum class PreferCompositionCreate(val value: kotlin.String) {
         @Json(name = "return=representation") representation("return=representation"),
         @Json(name = "return=minimal") minimal("return=minimal")
     }

    /**
     * Create COMPOSITION
     * Creates the first version of a new COMPOSITION in the EHR identified by &#x60;ehr_id&#x60;. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param composition The COMPOSITION. 
     * @param prefer Request header to indicate the preference over response details. The response will contain the entire resource when the &#x60;Prefer&#x60; header has a value of &#x60;return&#x3D;representation&#x60;.  (optional, default to return=minimal)
     * @return Composition
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun compositionCreate(ehrId: kotlin.String, composition: Composition, prefer: PreferCompositionCreate? = PreferCompositionCreate.minimal) : Composition {
        val localVarResponse = compositionCreateWithHttpInfo(ehrId = ehrId, composition = composition, prefer = prefer)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Composition
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create COMPOSITION
     * Creates the first version of a new COMPOSITION in the EHR identified by &#x60;ehr_id&#x60;. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param composition The COMPOSITION. 
     * @param prefer Request header to indicate the preference over response details. The response will contain the entire resource when the &#x60;Prefer&#x60; header has a value of &#x60;return&#x3D;representation&#x60;.  (optional, default to return=minimal)
     * @return ApiResponse<Composition?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun compositionCreateWithHttpInfo(ehrId: kotlin.String, composition: Composition, prefer: PreferCompositionCreate?) : ApiResponse<Composition?> {
        val localVariableConfig = compositionCreateRequestConfig(ehrId = ehrId, composition = composition, prefer = prefer)

        return request<Composition, Composition>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation compositionCreate
     *
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param composition The COMPOSITION. 
     * @param prefer Request header to indicate the preference over response details. The response will contain the entire resource when the &#x60;Prefer&#x60; header has a value of &#x60;return&#x3D;representation&#x60;.  (optional, default to return=minimal)
     * @return RequestConfig
     */
    fun compositionCreateRequestConfig(ehrId: kotlin.String, composition: Composition, prefer: PreferCompositionCreate?) : RequestConfig<Composition> {
        val localVariableBody = composition
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        prefer?.apply { localVariableHeaders["Prefer"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/ehr/{ehr_id}/composition".replace("{"+"ehr_id"+"}", encodeURIComponent(ehrId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Delete COMPOSITION
     * Deletes the COMPOSITION identified by &#x60;uid_based_id&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;.  The &#x60;uid_based_id&#x60; MUST be in a form of an OBJECT_VERSION_ID identifier taken from the last (most recent) VERSION.uid.value, representing the &#x60;preceding_version_uid&#x60; to be deleted. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An identifier in a form of an OBJECT_VERSION_ID identifier taken from VERSION.uid.value (i.e. a &#x60;version_uid&#x60;). 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun compositionDelete(ehrId: kotlin.String, uidBasedId: kotlin.String) : Unit {
        val localVarResponse = compositionDeleteWithHttpInfo(ehrId = ehrId, uidBasedId = uidBasedId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete COMPOSITION
     * Deletes the COMPOSITION identified by &#x60;uid_based_id&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;.  The &#x60;uid_based_id&#x60; MUST be in a form of an OBJECT_VERSION_ID identifier taken from the last (most recent) VERSION.uid.value, representing the &#x60;preceding_version_uid&#x60; to be deleted. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An identifier in a form of an OBJECT_VERSION_ID identifier taken from VERSION.uid.value (i.e. a &#x60;version_uid&#x60;). 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun compositionDeleteWithHttpInfo(ehrId: kotlin.String, uidBasedId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = compositionDeleteRequestConfig(ehrId = ehrId, uidBasedId = uidBasedId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation compositionDelete
     *
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An identifier in a form of an OBJECT_VERSION_ID identifier taken from VERSION.uid.value (i.e. a &#x60;version_uid&#x60;). 
     * @return RequestConfig
     */
    fun compositionDeleteRequestConfig(ehrId: kotlin.String, uidBasedId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/ehr/{ehr_id}/composition/{uid_based_id}".replace("{"+"ehr_id"+"}", encodeURIComponent(ehrId.toString())).replace("{"+"uid_based_id"+"}", encodeURIComponent(uidBasedId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get COMPOSITION
     * Retrieves a version of the COMPOSITION identified by &#x60;uid_based_id&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;.  The &#x60;uid_based_id&#x60; can take a form of an OBJECT_VERSION_ID identifier taken from VERSION.uid.value (i.e. a &#x60;version_uid&#x60;), or a form of a HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;). The former is used to retrieve a specific known version of the COMPOSITION (e.g. one identified by &#x60;8849182c-82ad-4088-a07f-48ead4180515::openEHRSys.example.com::1&#x60;), whereas the later (e.g. an identifier like &#x60;8849182c-82ad-4088-a07f-48ead4180515&#x60;) is be used to retrieve a version from the version container whenever the _version_tree_id_ is unknown or irrelevant (such as when most recent version is requested).  When the &#x60;uid_based_id&#x60; has the form of a HIER_OBJECT_ID, if the &#x60;version_at_time&#x60; is supplied, retrieves the version extant _at specified time_, otherwise retrieves the _latest_ COMPOSITION version.  See [Resource identification](overview.html#tag/Resources/Resource-identification) for more details about the identifiers usage and meaning. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An abstract identifier: it can take a form of an OBJECT_VERSION_ID identifier taken from VERSION.uid.value (i.e. a &#x60;version_uid&#x60;), or a form of a HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;). 
     * @param versionAtTime A given time in the extended ISO 8601 format.  (optional)
     * @return Composition
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun compositionGet(ehrId: kotlin.String, uidBasedId: kotlin.String, versionAtTime: kotlin.String? = null) : Composition {
        val localVarResponse = compositionGetWithHttpInfo(ehrId = ehrId, uidBasedId = uidBasedId, versionAtTime = versionAtTime)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Composition
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get COMPOSITION
     * Retrieves a version of the COMPOSITION identified by &#x60;uid_based_id&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;.  The &#x60;uid_based_id&#x60; can take a form of an OBJECT_VERSION_ID identifier taken from VERSION.uid.value (i.e. a &#x60;version_uid&#x60;), or a form of a HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;). The former is used to retrieve a specific known version of the COMPOSITION (e.g. one identified by &#x60;8849182c-82ad-4088-a07f-48ead4180515::openEHRSys.example.com::1&#x60;), whereas the later (e.g. an identifier like &#x60;8849182c-82ad-4088-a07f-48ead4180515&#x60;) is be used to retrieve a version from the version container whenever the _version_tree_id_ is unknown or irrelevant (such as when most recent version is requested).  When the &#x60;uid_based_id&#x60; has the form of a HIER_OBJECT_ID, if the &#x60;version_at_time&#x60; is supplied, retrieves the version extant _at specified time_, otherwise retrieves the _latest_ COMPOSITION version.  See [Resource identification](overview.html#tag/Resources/Resource-identification) for more details about the identifiers usage and meaning. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An abstract identifier: it can take a form of an OBJECT_VERSION_ID identifier taken from VERSION.uid.value (i.e. a &#x60;version_uid&#x60;), or a form of a HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;). 
     * @param versionAtTime A given time in the extended ISO 8601 format.  (optional)
     * @return ApiResponse<Composition?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun compositionGetWithHttpInfo(ehrId: kotlin.String, uidBasedId: kotlin.String, versionAtTime: kotlin.String?) : ApiResponse<Composition?> {
        val localVariableConfig = compositionGetRequestConfig(ehrId = ehrId, uidBasedId = uidBasedId, versionAtTime = versionAtTime)

        return request<Unit, Composition>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation compositionGet
     *
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An abstract identifier: it can take a form of an OBJECT_VERSION_ID identifier taken from VERSION.uid.value (i.e. a &#x60;version_uid&#x60;), or a form of a HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;). 
     * @param versionAtTime A given time in the extended ISO 8601 format.  (optional)
     * @return RequestConfig
     */
    fun compositionGetRequestConfig(ehrId: kotlin.String, uidBasedId: kotlin.String, versionAtTime: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (versionAtTime != null) {
                    put("version_at_time", listOf(versionAtTime.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ehr/{ehr_id}/composition/{uid_based_id}".replace("{"+"ehr_id"+"}", encodeURIComponent(ehrId.toString())).replace("{"+"uid_based_id"+"}", encodeURIComponent(uidBasedId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter prefer
     */
     enum class PreferCompositionUpdate(val value: kotlin.String) {
         @Json(name = "return=representation") representation("return=representation"),
         @Json(name = "return=minimal") minimal("return=minimal")
     }

    /**
     * Update COMPOSITION
     * Updates COMPOSITION identified by &#x60;uid_based_id&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;.  The &#x60;uid_based_id&#x60; can take only a form of an HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;).  If the request body already contains a COMPOSITION.uid.value, it must match the &#x60;uid_based_id&#x60; in the URL.   The existing latest &#x60;version_uid&#x60; of COMPOSITION resource (i.e. the &#x60;preceding_version_uid&#x60;) must be specified in the &#x60;If-Match&#x60; header. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An identifier in a form of a HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;). 
     * @param ifMatch Header to make the request conditional.  Together with &#x60;ETag&#x60; request tag, it helps to prevent simultaneous updates of a resource from overwriting each other (\&quot;mid-air collisions\&quot;). The format is always an &#x60;version_uid&#x60; identifier enclosed by double quotes. The operation will be performed only if the existing latest &#x60;version_uid&#x60; of the resource (i.e. the &#x60;preceding_version_uid&#x60;) matches this header&#39;s value. 
     * @param composition The new COMPOSITION. 
     * @param prefer Request header to indicate the preference over response details. The response will contain the entire resource when the &#x60;Prefer&#x60; header has a value of &#x60;return&#x3D;representation&#x60;.  (optional, default to return=minimal)
     * @return Composition
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun compositionUpdate(ehrId: kotlin.String, uidBasedId: kotlin.String, ifMatch: kotlin.String, composition: Composition, prefer: PreferCompositionUpdate? = PreferCompositionUpdate.minimal) : Composition {
        val localVarResponse = compositionUpdateWithHttpInfo(ehrId = ehrId, uidBasedId = uidBasedId, ifMatch = ifMatch, composition = composition, prefer = prefer)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Composition
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update COMPOSITION
     * Updates COMPOSITION identified by &#x60;uid_based_id&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;.  The &#x60;uid_based_id&#x60; can take only a form of an HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;).  If the request body already contains a COMPOSITION.uid.value, it must match the &#x60;uid_based_id&#x60; in the URL.   The existing latest &#x60;version_uid&#x60; of COMPOSITION resource (i.e. the &#x60;preceding_version_uid&#x60;) must be specified in the &#x60;If-Match&#x60; header. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An identifier in a form of a HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;). 
     * @param ifMatch Header to make the request conditional.  Together with &#x60;ETag&#x60; request tag, it helps to prevent simultaneous updates of a resource from overwriting each other (\&quot;mid-air collisions\&quot;). The format is always an &#x60;version_uid&#x60; identifier enclosed by double quotes. The operation will be performed only if the existing latest &#x60;version_uid&#x60; of the resource (i.e. the &#x60;preceding_version_uid&#x60;) matches this header&#39;s value. 
     * @param composition The new COMPOSITION. 
     * @param prefer Request header to indicate the preference over response details. The response will contain the entire resource when the &#x60;Prefer&#x60; header has a value of &#x60;return&#x3D;representation&#x60;.  (optional, default to return=minimal)
     * @return ApiResponse<Composition?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun compositionUpdateWithHttpInfo(ehrId: kotlin.String, uidBasedId: kotlin.String, ifMatch: kotlin.String, composition: Composition, prefer: PreferCompositionUpdate?) : ApiResponse<Composition?> {
        val localVariableConfig = compositionUpdateRequestConfig(ehrId = ehrId, uidBasedId = uidBasedId, ifMatch = ifMatch, composition = composition, prefer = prefer)

        return request<Composition, Composition>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation compositionUpdate
     *
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param uidBasedId An identifier in a form of a HIER_OBJECT_ID identifier taken from VERSIONED_OBJECT.uid.value (i.e. a &#x60;versioned_object_uid&#x60;). 
     * @param ifMatch Header to make the request conditional.  Together with &#x60;ETag&#x60; request tag, it helps to prevent simultaneous updates of a resource from overwriting each other (\&quot;mid-air collisions\&quot;). The format is always an &#x60;version_uid&#x60; identifier enclosed by double quotes. The operation will be performed only if the existing latest &#x60;version_uid&#x60; of the resource (i.e. the &#x60;preceding_version_uid&#x60;) matches this header&#39;s value. 
     * @param composition The new COMPOSITION. 
     * @param prefer Request header to indicate the preference over response details. The response will contain the entire resource when the &#x60;Prefer&#x60; header has a value of &#x60;return&#x3D;representation&#x60;.  (optional, default to return=minimal)
     * @return RequestConfig
     */
    fun compositionUpdateRequestConfig(ehrId: kotlin.String, uidBasedId: kotlin.String, ifMatch: kotlin.String, composition: Composition, prefer: PreferCompositionUpdate?) : RequestConfig<Composition> {
        val localVariableBody = composition
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ifMatch.apply { localVariableHeaders["If-Match"] = this.toString() }
        prefer?.apply { localVariableHeaders["Prefer"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/ehr/{ehr_id}/composition/{uid_based_id}".replace("{"+"ehr_id"+"}", encodeURIComponent(ehrId.toString())).replace("{"+"uid_based_id"+"}", encodeURIComponent(uidBasedId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get versioned COMPOSITION
     * Retrieves a VERSIONED_COMPOSITION identified by &#x60;versioned_object_uid&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @return VersionedComposition
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun versionedCompositionGet(ehrId: kotlin.String, versionedObjectUid: kotlin.String) : VersionedComposition {
        val localVarResponse = versionedCompositionGetWithHttpInfo(ehrId = ehrId, versionedObjectUid = versionedObjectUid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VersionedComposition
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get versioned COMPOSITION
     * Retrieves a VERSIONED_COMPOSITION identified by &#x60;versioned_object_uid&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @return ApiResponse<VersionedComposition?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun versionedCompositionGetWithHttpInfo(ehrId: kotlin.String, versionedObjectUid: kotlin.String) : ApiResponse<VersionedComposition?> {
        val localVariableConfig = versionedCompositionGetRequestConfig(ehrId = ehrId, versionedObjectUid = versionedObjectUid)

        return request<Unit, VersionedComposition>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation versionedCompositionGet
     *
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @return RequestConfig
     */
    fun versionedCompositionGetRequestConfig(ehrId: kotlin.String, versionedObjectUid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ehr/{ehr_id}/versioned_composition/{versioned_object_uid}".replace("{"+"ehr_id"+"}", encodeURIComponent(ehrId.toString())).replace("{"+"versioned_object_uid"+"}", encodeURIComponent(versionedObjectUid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get versioned COMPOSITION revision history
     * Retrieves revision history of the VERSIONED_COMPOSITION identified by &#x60;versioned_object_uid&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @return RevisionHistory
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun versionedCompositionRevisionHistory(ehrId: kotlin.String, versionedObjectUid: kotlin.String) : RevisionHistory {
        val localVarResponse = versionedCompositionRevisionHistoryWithHttpInfo(ehrId = ehrId, versionedObjectUid = versionedObjectUid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RevisionHistory
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get versioned COMPOSITION revision history
     * Retrieves revision history of the VERSIONED_COMPOSITION identified by &#x60;versioned_object_uid&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @return ApiResponse<RevisionHistory?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun versionedCompositionRevisionHistoryWithHttpInfo(ehrId: kotlin.String, versionedObjectUid: kotlin.String) : ApiResponse<RevisionHistory?> {
        val localVariableConfig = versionedCompositionRevisionHistoryRequestConfig(ehrId = ehrId, versionedObjectUid = versionedObjectUid)

        return request<Unit, RevisionHistory>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation versionedCompositionRevisionHistory
     *
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @return RequestConfig
     */
    fun versionedCompositionRevisionHistoryRequestConfig(ehrId: kotlin.String, versionedObjectUid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ehr/{ehr_id}/versioned_composition/{versioned_object_uid}/revision_history".replace("{"+"ehr_id"+"}", encodeURIComponent(ehrId.toString())).replace("{"+"versioned_object_uid"+"}", encodeURIComponent(versionedObjectUid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get versioned COMPOSITION version at time
     * Retrieves a VERSION from the VERSIONED_COMPOSITION identified by &#x60;versioned_object_uid&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;.  If &#x60;version_at_time&#x60; is supplied, retrieves the VERSION extant _at specified time_, otherwise retrieves the _latest_ VERSION. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @param versionAtTime A given time in the extended ISO 8601 format.  (optional)
     * @return Version
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun versionedCompositionVersionGetAtTime(ehrId: kotlin.String, versionedObjectUid: kotlin.String, versionAtTime: kotlin.String? = null) : Version {
        val localVarResponse = versionedCompositionVersionGetAtTimeWithHttpInfo(ehrId = ehrId, versionedObjectUid = versionedObjectUid, versionAtTime = versionAtTime)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Version
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get versioned COMPOSITION version at time
     * Retrieves a VERSION from the VERSIONED_COMPOSITION identified by &#x60;versioned_object_uid&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;.  If &#x60;version_at_time&#x60; is supplied, retrieves the VERSION extant _at specified time_, otherwise retrieves the _latest_ VERSION. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @param versionAtTime A given time in the extended ISO 8601 format.  (optional)
     * @return ApiResponse<Version?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun versionedCompositionVersionGetAtTimeWithHttpInfo(ehrId: kotlin.String, versionedObjectUid: kotlin.String, versionAtTime: kotlin.String?) : ApiResponse<Version?> {
        val localVariableConfig = versionedCompositionVersionGetAtTimeRequestConfig(ehrId = ehrId, versionedObjectUid = versionedObjectUid, versionAtTime = versionAtTime)

        return request<Unit, Version>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation versionedCompositionVersionGetAtTime
     *
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @param versionAtTime A given time in the extended ISO 8601 format.  (optional)
     * @return RequestConfig
     */
    fun versionedCompositionVersionGetAtTimeRequestConfig(ehrId: kotlin.String, versionedObjectUid: kotlin.String, versionAtTime: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (versionAtTime != null) {
                    put("version_at_time", listOf(versionAtTime.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ehr/{ehr_id}/versioned_composition/{versioned_object_uid}/version".replace("{"+"ehr_id"+"}", encodeURIComponent(ehrId.toString())).replace("{"+"versioned_object_uid"+"}", encodeURIComponent(versionedObjectUid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Get versioned COMPOSITION version by id
     * Retrieves a VERSION identified by &#x60;version_uid&#x60; of a VERSIONED_COMPOSITION identified by &#x60;versioned_object_uid&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @param versionUid VERSION identifier taken from VERSION.uid.value. 
     * @return Version
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun versionedCompositionVersionGetById(ehrId: kotlin.String, versionedObjectUid: kotlin.String, versionUid: kotlin.String) : Version {
        val localVarResponse = versionedCompositionVersionGetByIdWithHttpInfo(ehrId = ehrId, versionedObjectUid = versionedObjectUid, versionUid = versionUid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Version
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get versioned COMPOSITION version by id
     * Retrieves a VERSION identified by &#x60;version_uid&#x60; of a VERSIONED_COMPOSITION identified by &#x60;versioned_object_uid&#x60; and associated with the EHR identified by &#x60;ehr_id&#x60;. 
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @param versionUid VERSION identifier taken from VERSION.uid.value. 
     * @return ApiResponse<Version?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun versionedCompositionVersionGetByIdWithHttpInfo(ehrId: kotlin.String, versionedObjectUid: kotlin.String, versionUid: kotlin.String) : ApiResponse<Version?> {
        val localVariableConfig = versionedCompositionVersionGetByIdRequestConfig(ehrId = ehrId, versionedObjectUid = versionedObjectUid, versionUid = versionUid)

        return request<Unit, Version>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation versionedCompositionVersionGetById
     *
     * @param ehrId EHR identifier taken from EHR.ehr_id.value. 
     * @param versionedObjectUid VERSIONED_COMPOSITION identifier taken from VERSIONED_COMPOSITION.uid.value. 
     * @param versionUid VERSION identifier taken from VERSION.uid.value. 
     * @return RequestConfig
     */
    fun versionedCompositionVersionGetByIdRequestConfig(ehrId: kotlin.String, versionedObjectUid: kotlin.String, versionUid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/ehr/{ehr_id}/versioned_composition/{versioned_object_uid}/version/{version_uid}".replace("{"+"ehr_id"+"}", encodeURIComponent(ehrId.toString())).replace("{"+"versioned_object_uid"+"}", encodeURIComponent(versionedObjectUid.toString())).replace("{"+"version_uid"+"}", encodeURIComponent(versionUid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
