package org.openapitools.model;

import java.net.URI;
import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import java.util.ArrayList;
import java.util.List;
import org.openapitools.model.CodePhrase;
import org.openapitools.model.DataValue;
import org.openapitools.model.DvUri;
import org.openapitools.model.TermMapping;
import org.openapitools.jackson.nullable.JsonNullable;
import java.time.OffsetDateTime;
import javax.validation.Valid;
import javax.validation.constraints.*;
import io.swagger.v3.oas.annotations.media.Schema;


import java.util.*;
import javax.annotation.Generated;

/**
 * DvText
 */

@JsonIgnoreProperties(
  value = "_type", // ignore manually set _type, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the _type to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "_type", visible = true)
@JsonSubTypes({
  @JsonSubTypes.Type(value = DvCodedText.class, name = "DV_TEXT"),
  @JsonSubTypes.Type(value = DvText.class, name = "DV_TEXT")
})

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen")
public class DvText extends DataValue {

  private String type = "DV_TEXT";

  private String value;

  private DvUri hyperlink;

  private String formatting;

  @Valid
  private List<@Valid TermMapping> mappings;

  private CodePhrase language;

  private CodePhrase encoding;

  /**
   * Default constructor
   * @deprecated Use {@link DvText#DvText(String)}
   */
  @Deprecated
  public DvText() {
    super();
  }

  /**
   * Constructor with only required parameters
   */
  public DvText(String value) {
    super();
    this.value = value;
  }

  public DvText type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Get type
   * @return type
  */
  
  @Schema(name = "_type", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("_type")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public DvText value(String value) {
    this.value = value;
    return this;
  }

  /**
   * Get value
   * @return value
  */
  @NotNull 
  @Schema(name = "value", requiredMode = Schema.RequiredMode.REQUIRED)
  @JsonProperty("value")
  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }

  public DvText hyperlink(DvUri hyperlink) {
    this.hyperlink = hyperlink;
    return this;
  }

  /**
   * Get hyperlink
   * @return hyperlink
  */
  @Valid 
  @Schema(name = "hyperlink", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("hyperlink")
  public DvUri getHyperlink() {
    return hyperlink;
  }

  public void setHyperlink(DvUri hyperlink) {
    this.hyperlink = hyperlink;
  }

  public DvText formatting(String formatting) {
    this.formatting = formatting;
    return this;
  }

  /**
   * Get formatting
   * @return formatting
  */
  
  @Schema(name = "formatting", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("formatting")
  public String getFormatting() {
    return formatting;
  }

  public void setFormatting(String formatting) {
    this.formatting = formatting;
  }

  public DvText mappings(List<@Valid TermMapping> mappings) {
    this.mappings = mappings;
    return this;
  }

  public DvText addMappingsItem(TermMapping mappingsItem) {
    if (this.mappings == null) {
      this.mappings = new ArrayList<>();
    }
    this.mappings.add(mappingsItem);
    return this;
  }

  /**
   * Get mappings
   * @return mappings
  */
  @Valid 
  @Schema(name = "mappings", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("mappings")
  public List<@Valid TermMapping> getMappings() {
    return mappings;
  }

  public void setMappings(List<@Valid TermMapping> mappings) {
    this.mappings = mappings;
  }

  public DvText language(CodePhrase language) {
    this.language = language;
    return this;
  }

  /**
   * Get language
   * @return language
  */
  @Valid 
  @Schema(name = "language", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("language")
  public CodePhrase getLanguage() {
    return language;
  }

  public void setLanguage(CodePhrase language) {
    this.language = language;
  }

  public DvText encoding(CodePhrase encoding) {
    this.encoding = encoding;
    return this;
  }

  /**
   * Get encoding
   * @return encoding
  */
  @Valid 
  @Schema(name = "encoding", requiredMode = Schema.RequiredMode.NOT_REQUIRED)
  @JsonProperty("encoding")
  public CodePhrase getEncoding() {
    return encoding;
  }

  public void setEncoding(CodePhrase encoding) {
    this.encoding = encoding;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DvText dvText = (DvText) o;
    return Objects.equals(this.type, dvText.type) &&
        Objects.equals(this.value, dvText.value) &&
        Objects.equals(this.hyperlink, dvText.hyperlink) &&
        Objects.equals(this.formatting, dvText.formatting) &&
        Objects.equals(this.mappings, dvText.mappings) &&
        Objects.equals(this.language, dvText.language) &&
        Objects.equals(this.encoding, dvText.encoding) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, value, hyperlink, formatting, mappings, language, encoding, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DvText {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    hyperlink: ").append(toIndentedString(hyperlink)).append("\n");
    sb.append("    formatting: ").append(toIndentedString(formatting)).append("\n");
    sb.append("    mappings: ").append(toIndentedString(mappings)).append("\n");
    sb.append("    language: ").append(toIndentedString(language)).append("\n");
    sb.append("    encoding: ").append(toIndentedString(encoding)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

